"""
Contains classes that directly use the database
"""
from os import access, listdir, path, R_OK, W_OK
import pathlib
import sqlite3
from types import TracebackType

import feedparser as fp

from config import Config
from utilities import logger


class Database:
    """
    Defines database operations
    """

    def __init__(self, db_file: str = Config.database):
        self._db_file = db_file
        self._conn = sqlite3.connect(self._db_file)
        self._conn.execute('PRAGMA foreign_keys=ON')
        self.cursor = self._conn.cursor()
        self._logger = logger('database')

    def __enter__(self):
        return self

    def __exit__(self,
                 exc_type,
                 exc_val,
                 exc_tb: TracebackType):
        """
        If there are exceptions, rolls back and calls logger
        :param exc_type: exception type
        :param exc_val:  exception value
        :param exc_tb: exception traceback
        :return: None
        """
        if exc_type is not None:
            self._conn.rollback()
            self._logger.error(exc_type, exc_val, exc_tb)

        else:
            self._conn.commit()
        self._conn.close()

    def __repr__(self):
        return f'{self.__class__.__name__}({self._db_file})'

    def add_podcast(self, name: str, url: str, directory: str) -> None:
        """

        :param name: podcast name
        :param url: rss feed url
        :param directory: directory to store this podcast's downloaded episodes
        :return: None
        """
        self.cursor.executemany('INSERT INTO podcasts (name, url, directory) VALUES (?,?,?)',
                                ((name, url, directory),))
        self._conn.commit()

    def remove_podcast(self, url: str) -> None:
        """

        :param url: rss feed url
        :return: None
        """
        self.cursor.execute('DELETE FROM episodes WHERE podcast_id IN'
                            ' (SELECT id FROM podcasts p WHERE p.url = ?)', (url,))
        self.cursor.execute('DELETE FROM  podcasts WHERE url = ?',
                            (url,))
        self._conn.commit()

    def get_podcasts(self) -> list:
        """
        :return: list of tuples
        """
        self.cursor.execute('SELECT name, url, directory FROM main.podcasts')
        return self.cursor.fetchall()

    def add_episode(self,
                    podcast_url: str,
                    feed_id: str, ) -> None:
        """
        :param podcast_url: RSS feed URL
        :param feed_id: id generated by rss feed for each episode
        :return: None
        """
        self.cursor.execute('INSERT INTO episodes (feed_id, podcast_id) '
                            'SELECT ?, id FROM main.podcasts WHERE url = ?',
                            (feed_id, podcast_url))
        self._conn.commit()

    def get_episodes(self, url: str) -> set:
        """
        :param url: rss feed url
        :return: dict of episode ids associated with url
        """
        self.cursor.execute('SELECT feed_id FROM episodes '
                            'JOIN podcasts p ON episodes.podcast_id = p.id AND p.url = ?',
                            (url,))
        return {item[0] for item in self.cursor.fetchall()}

    def get_options(self) -> tuple:
        """
        :return: tuple of currently set options
        """
        self.cursor.execute('SELECT new_only, download_directory FROM settings')
        return self.cursor.fetchone()

    def change_option(self, option: str, value: str or int) -> None:
        """
        I know, I know, using a database query with an fstring is problematic,
        Ã  la bobby tables, but the user doesn't interact directly with the
        database with this or any other queries that use fstrings in queries.
        All values input by the user are parameterized, which mitigates the threat.
        Given what this application is and does, I'm not sure why any user would
        try to sql injection on a local db of which they have sole access.
        :param option: string, option to change
        :param value: string, option's new value
        :return: None
        """
        self.cursor.execute(f'UPDATE settings SET {option} = ? WHERE id = 1', (value,))
        self._conn.commit()


class Feed(Database):
    """
    Contains methods for managing rss feeds
    """

    def add(self, *urls) -> None:
        """
        Parses and validates rss feed urls, adds to database, creates
        download directory for each new feed added
        :param urls: rss feed urls
        :return: None
        """
        try:
            for url in urls:
                newest_only, dl_dir = self.get_options()
                feed = fp.parse(url)
                episodes = feed.entries
                if not episodes:
                    msg = f'No episodes at {url}'
                    print(msg)
                    self._logger.info(msg)
                    raise KeyError
                podcast_name = feed.feed.title
                podcast_dir = path.join(dl_dir, podcast_name)
                # url=feed.href covers cases when rss feeds redirect to a diff URL.
                # That was a fun one to figure out.
                self.add_podcast(name=podcast_name, url=feed.href, directory=podcast_dir)
                if newest_only:
                    self.new_podcast_only(feed=feed)
                pathlib.Path(podcast_dir).mkdir(parents=True, exist_ok=True)
                msg = f'{podcast_name} added!'
                print(msg)
                self._logger.info(msg)

        except sqlite3.IntegrityError:
            msg = f'{podcast_name} already in database.'
            self._logger.warning(msg)
            print(msg)
        except KeyError:
            self._logger.exception('Error, podcast not added')

    def remove(self) -> None:
        """
        Used with simple CLI interface, used to remove a podcast from database
        :return: None
        """
        podcasts = {i[0]: i[1] for i in enumerate(self.get_podcasts())}
        if not podcasts:
            print('You have no subscriptions!')
            return
        for num, podcast in podcasts.items():
            print(f'{num}: {podcast[0]}')
        try:
            choice = int(input('Podcast number to remove: '))
            if choice not in podcasts:
                print('Invalid option')
                return
            self.remove_podcast(podcasts[choice][1])
            msg = f'Removed {podcasts[choice][0]}'
            print(msg)
            self._logger.info(msg)
        except ValueError:
            print('Invalid option, enter a number')

    def new_podcast_only(self, feed: fp.FeedParserDict) -> None:
        """
        Loops through episodes, adding all episodes to the database, except for the newest one
        :param feed: FeedParserDict of a single feed
        :return: None
        """
        episodes = feed.entries
        first = episodes[0].published_parsed
        last = episodes[-1].published_parsed
        if first < last:  # Last is the latest episode, i.e., feed is reversed
            episodes = episodes[:-1]
        else:
            episodes = episodes[1:]
        for epi in episodes:
            self.add_episode(podcast_url=feed.href, feed_id=epi.id)

    def print_options(self) -> tuple:
        """
        Prints currently selected options
        :return: None
        """
        valid_options = {0: 'New podcasts download all episodes\n',
                         1: 'New podcasts download only new episodes\n'}
        new_only, download_directory = self.get_options()
        print('-- Options --')
        print(f'{valid_options[new_only]}Download Directory: {download_directory}')
        print(f'Database file: {self._db_file}')
        print('-------------')
        return new_only, download_directory

    def print_subscriptions(self) -> None:
        """
        :return: None
        """
        print('----------Current subscriptions----------')
        for sub in self.get_podcasts():
            print(sub[0])
        print('-----------------------------------------')

    def set_directory_option(self, directory) -> bool:
        """
        :param directory: string, abs path to base download directory
        :return: None
        """
        if access(directory, W_OK) and access(directory, R_OK):
            self.change_option('download_directory', directory)
            msg = f'Changed download directory to {directory}'
            print(msg)
            self._logger.info(msg)
            return True
        msg = f'Invalid directory: {directory}'
        print(msg)
        self._logger.warning(msg)
        return False

    def set_catalog_option(self, option) -> bool:
        """
        :param option: string, catalog option desired
        :return: None
        """
        valid_options = {'all': '0', 'new': '1'}
        if option not in valid_options:
            msg = f'Invalid option: {option}'
            print(msg)
            self._logger.warning(msg)
            return False
        self.change_option('new_only', valid_options[option])
        msg = f'Set catalog option to {option}'
        print(msg)
        self._logger.info(msg)
        return True


def create_database(database: str = Config.database) -> None:
    """
    Looks in the directory of the given filename, if the file is absent,
    it creates the database with default values.
    :param database: string, abs path of database file
    :return: None
    """
    files = [path.join(path.dirname(database), item) for item in
             listdir(path.dirname(database))]
    if database not in files:
        with Database(database) as _db:
            cur = _db.cursor
            cur.execute('CREATE TABLE IF NOT EXISTS podcasts '
                        '(id INTEGER PRIMARY KEY, '
                        'name TEXT, '
                        'url TEXT UNIQUE, '
                        'directory TEXT)')
            cur.execute('CREATE TABLE IF NOT EXISTS episodes '
                        '(id INTEGER PRIMARY KEY, '
                        'feed_id TEXT, '
                        'podcast_id INTEGER NOT NULL,'
                        'FOREIGN KEY (podcast_id) REFERENCES podcasts(id))')
            cur.execute('CREATE TABLE IF NOT EXISTS settings '
                        '(id INTEGER PRIMARY KEY, '
                        'new_only BOOLEAN, '
                        'download_directory TEXT)')
            cur.execute('INSERT INTO settings (new_only, download_directory) VALUES (?,?)',
                        (1, path.join(pathlib.Path.home(), 'Podcasts')), )
        pathlib.Path(path.join(path.dirname(path.abspath(__file__)), 'Logs')).mkdir(exist_ok=True)
